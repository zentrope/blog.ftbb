{:type :post
 :when "2013-11-15"
 :slug "set-my-language-free"
 :title "Episode 14: Set My Language Free!"
 :summary "Un-premeditated tools."
 :tags "tech,functional,software,development,clojure,scala,javascript,keith,irwin,christoph,neumann"
 :publish? true
 :media-url "episode/2013-11-15-episode-14.mp3"
 :media-length "44628566"
 :media-duration "1:14:20"}

Christoph and Keith explore the intersection between the technological
bedrock we take as given when we develop software systems, such as
operating systems, TCP/IP networks, files, automatic memory management
(and maybe even <small>HTTP</small>), and the free floating ideas we
have before we ever write a line of code.

Say 'technological bedrock' represents constraints (or the reality)
you can't change, and ideas represent imaginitive worlds you want to
bring into being. If that's the case, then programming languages
become the means by which you move from imagination to reality.
They're artistic materials: the raw stuff out of which a
representation is made.

If so, why do language developers (and perhaps more earnestly,
language users) insist on hardening languages to a sub-set of
possibilities? This language requires built-in unit tests, that one
doesn't. The one over there insists that everything is an object,
while this one insists that everything is a value. Finally, we have a
language with a type system so rich it's turing complete, while over
there, a string is a number, depending on what it contains.

Wouldn't it be great to have a language in which you can build just
the OO you needed, when you needed it? Or what about one in which
compile-time static typing were optional for just those areas where it
provides real benefit?

What if we think of programming languages more like poets think of
words, or painters of paint?

This and more on Flipping the Bozo Bit Episode 14.

**Links!**

Some fun stuff mentioned (sometimes in spirit) in Episode 14:

 - [Pyret][pyret]:<br/> A programming language in which unit tests are
   part of a function's definition.

 - [Clojure][clj]:<br/> An expressive, minimilist Lisp for the JVM.

 - [Scala][scala]:<br/> A scalable, multi-paradigm language.

 - [Narcissism of small code differences][nscd]:<br/>A wonderful post
   about how developers interact with each other and code. The
   comments are an excellent example of the principle in action.

 - [Narcissistic Design - Stuart Halloway][narc]:<br/>Stuart
   illustrates how, often, the "best practices" baked into our
   languages, techniques and assumptions are, in fact, worst
   practices.

And finally:

<div class="audio-wrapper">
  <audio controls>
    <source src="/episode/2013-11-15-episode-14.mp3" type="audio/mpeg"/>
  </audio>
  <div class="audio-download">
    <a href="/episode/2013-11-15-episode-14.mp3">Download MP3</a>
  </div>
</div>

[nscd]: http://raganwald.com/2008/05/narcissism-of-small-code-differences.html
[clj]: http://clojure.org
[scala]: http://www.scala-lang.org
[narc]: http://vimeo.com/77199361
[pyret]: http://www.pyret.org
